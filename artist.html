<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Visionary Infinite Canvas</title>
    <style>
        :root {
            --bg-color: #0a0a0a;
            --ui-bg: rgba(30, 30, 30, 0.85);
            --accent: #007AFF;
            --text: #ffffff;
        }

        body, html {
            margin: 0;
            padding: 0;
            width: 100%;
            height: 100%;
            overflow: hidden;
            background-color: var(--bg-color);
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
        }

        canvas {
            display: block;
            touch-action: none; /* Prevents browser handling of gestures */
        }

        /* UI Overlay */
        #ui-layer {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 10;
        }

        .panel {
            position: absolute;
            background: var(--ui-bg);
            backdrop-filter: blur(10px);
            border-radius: 12px;
            padding: 10px;
            pointer-events: auto;
            box-shadow: 0 8px 32px rgba(0,0,0,0.5);
            border: 1px solid rgba(255,255,255,0.1);
            display: flex;
            gap: 10px;
            align-items: center;
        }

        #toolbar {
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
        }

        #status-bar {
            top: 20px;
            left: 20px;
            font-size: 12px;
            color: var(--text);
            opacity: 0.7;
        }

        #export-panel {
            top: 20px;
            right: 20px;
        }

        button, input[type="color"], select {
            background: #333;
            border: none;
            color: white;
            padding: 8px 12px;
            border-radius: 6px;
            cursor: pointer;
            font-size: 14px;
        }

        button:active {
            background: var(--accent);
        }

        .tool-active {
            background: var(--accent) !important;
        }

        input[type="range"] {
            width: 80px;
        }

        /* Modal for Export */
        #export-modal {
            display: none;
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: #1e1e1e;
            padding: 20px;
            border-radius: 15px;
            z-index: 100;
            width: 300px;
            border: 1px solid #444;
        }

        .overlay {
            display: none;
            position: fixed;
            top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.8);
            z-index: 99;
        }
    </style>
</head>
<body>

    <canvas id="canvas"></canvas>

    <div id="ui-layer">
        <div id="status-bar" class="panel">
            Zoom: <span id="zoom-val">100%</span>
        </div>

        <div id="export-panel" class="panel">
            <button onclick="showExport()">Export Frame</button>
            <button onclick="clearCanvas()" style="color: #ff4444;">Clear</button>
        </div>

        <div id="toolbar" class="panel">
            <input type="color" id="colorPicker" value="#ffffff">
            <select id="toolType">
                <option value="pen">Sharp Pen</option>
                <option value="brush">Soft Brush</option>
                <option value="pencil">Pencil</option>
            </select>
            <input type="range" id="sizePicker" min="1" max="50" value="2">
            <button id="btn-draw" class="tool-active" onclick="setMode('draw')">Draw</button>
            <button id="btn-pan" onclick="setMode('pan')">Pan/Zoom</button>
        </div>
    </div>

    <div id="export-modal-overlay" class="overlay" onclick="hideExport()"></div>
    <div id="export-modal">
        <h3 style="color:white; margin-top:0;">Export Settings</h3>
        <label style="color:#aaa; font-size:12px;">Width (Pixels)</label><br>
        <input type="number" id="expWidth" value="1920" style="width:100%; margin-bottom:10px;"><br>
        <label style="color:#aaa; font-size:12px;">Quality (1-10)</label><br>
        <input type="number" id="expQual" value="10" style="width:100%; margin-bottom:20px;">
        <button onclick="performExport()" style="width:100%; background: var(--accent);">Download PNG</button>
    </div>

<script>
    const canvas = document.getElementById('canvas');
    const ctx = canvas.getContext('2d');
    const zoomDisplay = document.getElementById('zoom-val');
    
    // Application State
    let strokes = [];
    let currentStroke = null;
    let camera = { x: 0, y: 0, zoom: 1 };
    let mode = 'draw'; // 'draw' or 'pan'
    let isDragging = false;
    let lastMousePos = { x: 0, y: 0 };
    let touchStartDist = 0;
    let touchStartZoom = 1;

    // Initialization
    function resize() {
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;
        render();
    }
    window.addEventListener('resize', resize);
    resize();

    // Input Handling
    canvas.addEventListener('pointerdown', e => {
        isDragging = true;
        lastMousePos = { x: e.clientX, y: e.clientY };

        if (mode === 'draw' && e.pointerType !== 'mouse' || (mode === 'draw' && e.buttons === 1)) {
            const pos = screenToWorld(e.clientX, e.clientY);
            currentStroke = {
                color: document.getElementById('colorPicker').value,
                size: document.getElementById('sizePicker').value / camera.zoom,
                type: document.getElementById('toolType').value,
                points: [pos]
            };
            strokes.push(currentStroke);
        }
    });

    canvas.addEventListener('pointermove', e => {
        if (!isDragging) return;

        if (mode === 'pan' || (e.buttons === 2) || (e.pointerType === 'touch' && e.shiftKey)) {
            // Panning logic
            const dx = e.clientX - lastMousePos.x;
            const dy = e.clientY - lastMousePos.y;
            camera.x += dx;
            camera.y += dy;
            lastMousePos = { x: e.clientX, y: e.clientY };
        } else if (mode === 'draw' && currentStroke) {
            // Drawing logic
            const pos = screenToWorld(e.clientX, e.clientY);
            currentStroke.points.push(pos);
        }
        render();
    });

    canvas.addEventListener('pointerup', () => {
        isDragging = false;
        currentStroke = null;
    });

    // Infinite Zoom via Mouse Wheel
    canvas.addEventListener('wheel', e => {
        e.preventDefault();
        const zoomSpeed = 0.001;
        const delta = -e.deltaY;
        const factor = Math.pow(1.1, delta / 100);
        
        applyZoom(factor, e.clientX, e.clientY);
    }, { passive: false });

    // Touch Pinch-to-Zoom
    let activeTouches = [];
    canvas.addEventListener('touchstart', e => {
        if (e.touches.length === 2) {
            touchStartDist = Math.hypot(
                e.touches[0].pageX - e.touches[1].pageX,
                e.touches[0].pageY - e.touches[1].pageY
            );
            touchStartZoom = camera.zoom;
        }
    }, { passive: false });

    canvas.addEventListener('touchmove', e => {
        if (e.touches.length === 2) {
            const dist = Math.hypot(
                e.touches[0].pageX - e.touches[1].pageX,
                e.touches[0].pageY - e.touches[1].pageY
            );
            const centerX = (e.touches[0].pageX + e.touches[1].pageX) / 2;
            const centerY = (e.touches[0].pageY + e.touches[1].pageY) / 2;
            
            const factor = dist / touchStartDist;
            applyZoom(factor / (camera.zoom / touchStartZoom), centerX, centerY);
        }
    }, { passive: false });

    function applyZoom(factor, centerX, centerY) {
        const worldPos = screenToWorld(centerX, centerY);
        camera.zoom *= factor;
        
        // Clamp zoom to prevent infinitesimal values
        if (camera.zoom < 0.00001) camera.zoom = 0.00001;
        if (camera.zoom > 10000) camera.zoom = 10000;

        // Reposition camera so zoom is centered on cursor/pinch
        camera.x = centerX - worldPos.x * camera.zoom;
        camera.y = centerY - worldPos.y * camera.zoom;
        
        zoomDisplay.innerText = Math.round(camera.zoom * 100) + '%';
        render();
    }

    function screenToWorld(sx, sy) {
        return {
            x: (sx - camera.x) / camera.zoom,
            y: (sy - camera.y) / camera.zoom
        };
    }

    // Core Rendering Engine
    function render() {
        ctx.fillStyle = '#0a0a0a'; // Blackboard background
        ctx.fillRect(0, 0, canvas.width, canvas.height);

        ctx.save();
        ctx.translate(camera.x, camera.y);
        ctx.scale(camera.zoom, camera.zoom);

        strokes.forEach(stroke => {
            if (stroke.points.length < 2) return;

            ctx.beginPath();
            ctx.strokeStyle = stroke.color;
            ctx.lineWidth = stroke.size;
            ctx.lineCap = 'round';
            ctx.lineJoin = 'round';

            if (stroke.type === 'brush') {
                ctx.globalAlpha = 0.3;
                ctx.shadowBlur = stroke.size / 2;
                ctx.shadowColor = stroke.color;
            } else if (stroke.type === 'pencil') {
                ctx.globalAlpha = 0.8;
                ctx.setLineDash([1, 2]);
            } else {
                ctx.globalAlpha = 1.0;
                ctx.setLineDash([]);
                ctx.shadowBlur = 0;
            }

            ctx.moveTo(stroke.points[0].x, stroke.points[0].y);
            for (let i = 1; i < stroke.points.length; i++) {
                ctx.lineTo(stroke.points[i].x, stroke.points[i].y);
            }
            ctx.stroke();
        });

        ctx.restore();
    }

    // UI Logic
    function setMode(m) {
        mode = m;
        document.getElementById('btn-draw').classList.toggle('tool-active', m === 'draw');
        document.getElementById('btn-pan').classList.toggle('tool-active', m === 'pan');
    }

    function clearCanvas() {
        if(confirm("Clear everything?")) {
            strokes = [];
            camera = { x: 0, y: 0, zoom: 1 };
            zoomDisplay.innerText = '100%';
            render();
        }
    }

    // Modernized Export Engine
    function showExport() {
        document.getElementById('export-modal').style.display = 'block';
        document.getElementById('export-modal-overlay').style.display = 'block';
    }

    function hideExport() {
        document.getElementById('export-modal').style.display = 'none';
        document.getElementById('export-modal-overlay').style.display = 'none';
    }

    function performExport() {
        const exportWidth = parseInt(document.getElementById('expWidth').value);
        const aspect = canvas.width / canvas.height;
        const exportHeight = exportWidth / aspect;

        // Create off-screen high-res canvas
        const tempCanvas = document.createElement('canvas');
        tempCanvas.width = exportWidth;
        tempCanvas.height = exportHeight;
        const tCtx = tempCanvas.getContext('2d');

        // Draw background
        tCtx.fillStyle = '#0a0a0a';
        tCtx.fillRect(0, 0, exportWidth, exportHeight);

        // Calculate scaling for the high-res export
        const scaleMult = exportWidth / canvas.width;

        tCtx.save();
        // Match the current viewport but scaled up
        tCtx.translate(camera.x * scaleMult, camera.y * scaleMult);
        tCtx.scale(camera.zoom * scaleMult, camera.zoom * scaleMult);

        strokes.forEach(stroke => {
            tCtx.beginPath();
            tCtx.strokeStyle = stroke.color;
            tCtx.lineWidth = stroke.size;
            tCtx.lineCap = 'round';
            tCtx.lineJoin = 'round';
            
            // Re-apply style logic for export
            if (stroke.type === 'brush') tCtx.globalAlpha = 0.3;
            else tCtx.globalAlpha = 1.0;

            tCtx.moveTo(stroke.points[0].x, stroke.points[0].y);
            for (let i = 1; i < stroke.points.length; i++) {
                tCtx.lineTo(stroke.points[i].x, stroke.points[i].y);
            }
            tCtx.stroke();
        });
        tCtx.restore();

        // Download logic
        const link = document.createElement('a');
        link.download = `visionary-art-${Date.now()}.png`;
        link.href = tempCanvas.toDataURL('image/png');
        link.click();
        hideExport();
    }

    // Initial Render
    render();
</script>
</body>
</html>