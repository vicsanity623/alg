<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <title>Visionary Infinite Canvas</title>
    <link rel="manifest" href="manifest.json">
    <style>
        :root {
            --bg-color: #0a0a0a;
            --ui-bg: rgba(30, 30, 30, 0.9);
            --accent: #007AFF;
            --text: #ffffff;
        }

        body, html {
            margin: 0; padding: 0; width: 100%; height: 100%;
            overflow: hidden; background-color: var(--bg-color);
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif;
            overscroll-behavior: none;
        }

        canvas { display: block; touch-action: none; background-color: #0a0a0a; }

        #ui-layer { position: fixed; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; z-index: 10; }

        .panel {
            position: absolute; background: var(--ui-bg); backdrop-filter: blur(15px);
            border-radius: 14px; padding: 12px; pointer-events: auto;
            box-shadow: 0 8px 32px rgba(0,0,0,0.6); border: 1px solid rgba(255,255,255,0.1);
            display: flex; gap: 12px; align-items: center;
        }

        #toolbar {
            top: 50%; left: 15px; transform: translateY(-50%);
            flex-direction: column; padding: 20px 10px;
            margin-left: env(safe-area-inset-left);
            max-height: 85vh; overflow-y: auto;
        }

        #status-bar { top: 20px; left: 20px; font-size: 11px; color: var(--text); opacity: 0.8; font-weight: bold; }
        #export-panel { top: 20px; right: 20px; display: flex; gap: 8px; }

        button, input[type="color"], select {
            background: #222; border: none; color: white;
            padding: 10px; border-radius: 10px; cursor: pointer;
            font-size: 16px; width: 48px; height: 48px;
            display: flex; align-items: center; justify-content: center;
        }

        select, #sizePicker { width: 65px; }
        button:active { background: var(--accent); }
        .tool-active { background: var(--accent) !important; box-shadow: 0 0 15px var(--accent); }

        input[type="range"] {
            writing-mode: bt-lr; -webkit-appearance: slider-vertical;
            width: 24px; height: 100px; margin: 10px 0;
        }

        #export-modal {
            display: none; position: fixed; top: 50%; left: 50%;
            transform: translate(-50%, -50%); background: #161616;
            padding: 25px; border-radius: 20px; z-index: 100;
            width: 320px; border: 1px solid #333; pointer-events: auto;
        }

        .overlay {
            display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.85); z-index: 99; pointer-events: auto;
        }
        
        .label-text { display: block; font-size: 9px; text-transform: uppercase; color: #999; letter-spacing: 1px; margin-bottom: 4px; }
    </style>
</head>
<body>

<canvas id="canvas"></canvas>

<div id="ui-layer">
    <div id="status-bar" class="panel">ZOOM: <span id="zoom-val">100%</span></div>

    <div id="export-panel" class="panel">
        <button onclick="showExport()" style="width: auto; padding: 0 15px;">Export</button>
        <button onclick="clearCanvas()" style="color: #ff4444; width: auto; padding: 0 15px;">Clear</button>
    </div>

    <div id="toolbar" class="panel">
        <span class="label-text">Color</span>
        <input type="color" id="colorPicker" value="#44ffaa">
        
        <span class="label-text">Tool</span>
        <select id="toolType">
            <option value="pen">Pen</option>
            <option value="brush">Brush</option>
            <option value="pencil">Pencil</option>
            <option value="eraser">Eraser</option>
        </select>
        
        <span class="label-text">Size</span>
        <input type="range" id="sizePicker" min="1" max="200" value="15">

        <span class="label-text">Flow</span>
        <input type="range" id="opacityPicker" min="1" max="100" value="100">
        
        <button id="btn-draw" class="tool-active" onclick="setMode('draw')" title="Draw Mode">✎</button>
        <button id="btn-pan" onclick="setMode('pan')" title="Adjust Mode">✥</button>
    </div>
</div>

<div id="export-modal-overlay" class="overlay" onclick="hideExport()"></div>
<div id="export-modal">
    <h3 style="color:white; margin-top:0;">Precision Export</h3>
    <label class="label-text">Resolution Width (px)</label>
    <input type="number" id="expWidth" value="3840" style="width:100%; margin-bottom:15px; background:#000; color:#fff; border:1px solid #444; padding:8px; border-radius:8px;">
    
    <label class="label-text">Format</label>
    <select id="expFormat" style="width: 100%; margin-bottom: 15px; height: 45px;">
        <option value="image/png">PNG (Lossless)</option>
        <option value="image/jpeg">JPEG (Compressed)</option>
    </select>

    <label class="label-text">Background</label>
    <select id="expBG" style="width: 100%; margin-bottom: 15px; height: 45px;">
        <option value="#0a0a0a">Black</option>
        <option value="#ffffff">White</option>
        <option value="transparent">Transparent</option>
    </select>
    
    <button onclick="performExport()" style="width:100%; background: var(--accent); height:auto; padding:15px; font-weight:bold; border-radius:12px;">Save to Device</button>
</div>

<script>
    const canvas = document.getElementById('canvas');
    const ctx = canvas.getContext('2d', { alpha: false, desynchronized: true }); 
    const zoomDisplay = document.getElementById('zoom-val');
    
    let strokes = [];
    let currentStroke = null;
    let camera = { x: 0, y: 0, zoom: 1 };
    let mode = 'draw'; 
    let isDragging = false;
    let isPinching = false;
    let crosshairActive = false;
    let crosshairPos = { x: 0, y: 0 };
    let crosshairOffset = { x: 0, y: 0 };
    let initialPinchDist = 0;
    let initialPinchZoom = 1;
    let lastTapTime = 0;
    let visualTouches = [];

    function resize() {
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;
    }
    window.addEventListener('resize', resize);
    resize();

    function screenToWorld(sx, sy) {
        return { x: (sx - camera.x) / camera.zoom, y: (sy - camera.y) / camera.zoom };
    }

    function undo() { if (strokes.length > 0) strokes.pop(); }

    function startNewStroke(x, y) {
        const pos = screenToWorld(x, y);
        currentStroke = {
            color: document.getElementById('colorPicker').value,
            size: document.getElementById('sizePicker').value / camera.zoom,
            opacity: document.getElementById('opacityPicker').value / 100,
            type: document.getElementById('toolType').value,
            points: [{...pos, p: 0.5}]
        };
        strokes.push(currentStroke);
        if (strokes.length > 500) strokes.shift();
    }

    canvas.addEventListener('touchstart', e => {
        if (mode === 'draw') {
            if (e.touches.length === 2) {
                isPinching = true;
                crosshairActive = true;
                isDragging = false;
                currentStroke = null;
                const t1 = e.touches[0], t2 = e.touches[1];
                crosshairPos.x = (t1.clientX + t2.clientX) / 2;
                crosshairPos.y = (t1.clientY + t2.clientY) / 2;
            } else if (e.touches.length === 1) {
                const now = Date.now();
                if (now - lastTapTime < 300) {
                    undo(); undo();
                    lastTapTime = 0;
                    return;
                }
                lastTapTime = now;
                isDragging = true;
                startNewStroke(e.touches[0].clientX, e.touches[0].clientY);
                addVisualTouch(e.touches[0].clientX, e.touches[0].clientY);
            }
        } else {
            if (e.touches.length === 2) {
                isPinching = true;
                initialPinchDist = Math.hypot(e.touches[0].clientX-e.touches[1].clientX, e.touches[0].clientY-e.touches[1].clientY);
                initialPinchZoom = camera.zoom;
            } else {
                isDragging = true;
                crosshairPos = { x: e.touches[0].clientX, y: e.touches[0].clientY };
            }
        }
    }, { passive: false });

    canvas.addEventListener('touchmove', e => {
        e.preventDefault();
        if (mode === 'draw') {
            if (isPinching && e.touches.length === 2) {
                crosshairPos.x = (e.touches[0].clientX + e.touches[1].clientX) / 2;
                crosshairPos.y = (e.touches[0].clientY + e.touches[1].clientY) / 2;
            } else if (isDragging && currentStroke) {
                let x = e.touches[0].clientX;
                let y = e.touches[0].clientY;
                if (crosshairActive) {
                    x -= crosshairOffset.x;
                    y -= crosshairOffset.y;
                }
                const pos = screenToWorld(x, y);
                currentStroke.points.push({...pos, p: 0.5});
            }
        } else {
            if (isPinching && e.touches.length === 2) {
                const dist = Math.hypot(e.touches[0].clientX-e.touches[1].clientX, e.touches[0].clientY-e.touches[1].clientY);
                const cx = (e.touches[0].clientX + e.touches[1].clientX) / 2;
                const cy = (e.touches[0].clientY + e.touches[1].clientY) / 2;
                applyZoom(initialPinchZoom * (dist / initialPinchDist) / camera.zoom, cx, cy);
            } else if (isDragging) {
                camera.x += (e.touches[0].clientX - crosshairPos.x);
                camera.y += (e.touches[0].clientY - crosshairPos.y);
                crosshairPos = { x: e.touches[0].clientX, y: e.touches[0].clientY };
            }
        }
    }, { passive: false });

    canvas.addEventListener('touchend', e => {
        if (mode === 'draw') {
            if (isPinching && e.touches.length === 1) {
                isPinching = false;
                isDragging = true;
                // RELATIVE LOCK: Calculate how far the remaining finger is from the crosshair
                crosshairOffset.x = e.touches[0].clientX - crosshairPos.x;
                crosshairOffset.y = e.touches[0].clientY - crosshairPos.y;
                startNewStroke(crosshairPos.x, crosshairPos.y);
            } else if (e.touches.length === 0) {
                isDragging = false; crosshairActive = false; currentStroke = null;
            }
        } else {
            if (e.touches.length < 2) isPinching = false;
            if (e.touches.length === 0) isDragging = false;
        }
    });

    function applyZoom(factor, cx, cy) {
        const world = screenToWorld(cx, cy);
        camera.zoom *= factor;
        camera.zoom = Math.max(0.00001, Math.min(10000, camera.zoom));
        camera.x = cx - world.x * camera.zoom;
        camera.y = cy - world.y * camera.zoom;
        zoomDisplay.innerText = Math.round(camera.zoom * 100) + '%';
    }

    function addVisualTouch(x, y) {
        visualTouches.push({ x, y, radius: 20, alpha: 0.6, color: document.getElementById('colorPicker').value });
    }

    function drawPaths(tCtx, cam) {
        strokes.forEach(s => {
            if (!s.points.length) return;
            tCtx.save();
            tCtx.lineCap = 'round'; tCtx.lineJoin = 'round';
            if (s.type === 'eraser') {
                tCtx.globalCompositeOperation = 'destination-out';
                tCtx.strokeStyle = 'white'; tCtx.globalAlpha = 1;
            } else {
                tCtx.globalCompositeOperation = 'source-over';
                tCtx.strokeStyle = s.color; tCtx.fillStyle = s.color;
                tCtx.globalAlpha = s.opacity;
            }
            if (s.type === 'brush') {
                tCtx.shadowBlur = (s.size * cam.zoom) / 3;
                tCtx.shadowColor = s.color;
            } else if (s.type === 'pencil') {
                tCtx.setLineDash([1 / cam.zoom, 2 / cam.zoom]);
                tCtx.globalAlpha *= 0.6;
            }
            if (s.points.length === 1) {
                tCtx.beginPath();
                tCtx.arc(s.points[0].x, s.points[0].y, s.size/2, 0, Math.PI*2);
                tCtx.fill();
            } else {
                tCtx.beginPath();
                tCtx.moveTo(s.points[0].x, s.points[0].y);
                s.points.forEach(p => tCtx.lineTo(p.x, p.y));
                tCtx.lineWidth = s.size;
                tCtx.stroke();
            }
            tCtx.restore();
        });
    }

    function drawCrosshair() {
        if (!crosshairActive) return;
        ctx.save();
        ctx.setTransform(1, 0, 0, 1, 0, 0);
        ctx.strokeStyle = "#00ff66";
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.moveTo(crosshairPos.x - 40, crosshairPos.y); ctx.lineTo(crosshairPos.x + 40, crosshairPos.y);
        ctx.moveTo(crosshairPos.x, crosshairPos.y - 40); ctx.lineTo(crosshairPos.x, crosshairPos.y + 40);
        ctx.stroke();
        ctx.beginPath(); ctx.arc(crosshairPos.x, crosshairPos.y, 15, 0, Math.PI * 2); ctx.stroke();
        ctx.restore();
    }

    function renderLoop() {
        // HARD WIPE: Prevents all Adjust Mode trails
        ctx.setTransform(1, 0, 0, 1, 0, 0);
        ctx.fillStyle = '#0a0a0a';
        ctx.fillRect(0, 0, canvas.width, canvas.height);

        ctx.save();
        ctx.translate(camera.x, camera.y);
        ctx.scale(camera.zoom, camera.zoom);
        drawPaths(ctx, camera);
        ctx.restore();

        drawCrosshair();

        visualTouches.forEach((t, i) => {
            ctx.beginPath(); ctx.fillStyle = t.color; ctx.globalAlpha = t.alpha;
            ctx.arc(t.x, t.y, t.radius, 0, Math.PI * 2); ctx.fill();
            t.alpha -= 0.05; t.radius += 1;
            if (t.alpha <= 0) visualTouches.splice(i, 1);
        });

        requestAnimationFrame(renderLoop);
    }

    function setMode(m) {
        mode = m;
        isDragging = false; crosshairActive = false; currentStroke = null;
        document.getElementById('btn-draw').classList.toggle('tool-active', m === 'draw');
        document.getElementById('btn-pan').classList.toggle('tool-active', m === 'pan');
    }

    function clearCanvas() { if(confirm("Clear Blackboard?")) { strokes = []; camera = {x:0,y:0,zoom:1}; } }
    function showExport() { document.getElementById('export-modal').style.display = 'block'; document.getElementById('export-modal-overlay').style.display = 'block'; }
    function hideExport() { document.getElementById('export-modal').style.display = 'none'; document.getElementById('export-modal-overlay').style.display = 'none'; }

    function performExport() {
        if (!strokes.length) return;
        let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;
        strokes.forEach(s => s.points.forEach(p => {
            minX = Math.min(minX, p.x); minY = Math.min(minY, p.y);
            maxX = Math.max(maxX, p.x); maxY = Math.max(maxY, p.y);
        }));
        const pad = Math.max(maxX - minX, maxY - minY) * 0.05;
        minX -= pad; minY -= pad; maxX += pad; maxY += pad;
        const width = parseInt(document.getElementById('expWidth').value) || 3840;
        const scale = width / (maxX - minX);
        const height = (maxY - minY) * scale;
        const out = document.createElement('canvas');
        out.width = width; out.height = height;
        const octx = out.getContext('2d', {alpha: true});
        const bg = document.getElementById('expBG').value;
        if (bg !== 'transparent') { octx.fillStyle = bg; octx.fillRect(0,0,width,height); }
        octx.save(); octx.scale(scale, scale); octx.translate(-minX, -minY);
        drawPaths(octx, { zoom: scale });
        octx.restore();
        const link = document.createElement('a');
        link.download = `visionary-art-${Date.now()}.png`;
        link.href = out.toDataURL(document.getElementById('expFormat').value);
        link.click(); hideExport();
    }

    if ('serviceWorker' in navigator) {
        window.addEventListener('load', () => { navigator.serviceWorker.register('sw.js').catch(() => {}); });
    }

    requestAnimationFrame(renderLoop);
</script>
</body>
</html>