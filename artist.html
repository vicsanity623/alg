<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <title>Visionary Infinite Canvas</title>
    <link rel="manifest" href="manifest.json">
    <style>
        :root {
            --bg-color: #0a0a0a;
            --ui-bg: rgba(30, 30, 30, 0.85);
            --accent: #007AFF;
            --text: #ffffff;
        }

        body, html {
            margin: 0;
            padding: 0;
            width: 100%;
            height: 100%;
            overflow: hidden;
            background-color: var(--bg-color);
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
            overscroll-behavior: none;
        }

        canvas {
            display: block;
            touch-action: none; 
            background-color: #0a0a0a;
        }

        #ui-layer {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 10;
        }

        .panel {
            position: absolute;
            background: var(--ui-bg);
            backdrop-filter: blur(10px);
            border-radius: 12px;
            padding: 10px;
            pointer-events: auto;
            box-shadow: 0 8px 32px rgba(0,0,0,0.5);
            border: 1px solid rgba(255,255,255,0.1);
            display: flex;
            gap: 10px;
            align-items: center;
        }

        #toolbar {
            top: 50%;
            left: 15px;
            transform: translateY(-50%);
            flex-direction: column;
            padding: 15px 8px;
            margin-left: env(safe-area-inset-left);
            max-height: 90vh;
            overflow-y: auto;
        }

        #status-bar {
            top: 20px;
            left: 20px;
            font-size: 12px;
            color: var(--text);
            opacity: 0.7;
        }

        #export-panel {
            top: 20px;
            right: 20px;
            display: flex;
            gap: 8px;
        }

        button, input[type="color"], select {
            background: #333;
            border: none;
            color: white;
            padding: 10px;
            border-radius: 8px;
            cursor: pointer;
            font-size: 14px;
            width: 44px; 
            height: 44px;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: background 0.2s;
        }

        select, #sizePicker {
            width: 60px;
        }

        button:active {
            background: var(--accent);
        }

        .tool-active {
            background: var(--accent) !important;
        }

        input[type="range"] {
            writing-mode: bt-lr; 
            -webkit-appearance: slider-vertical;
            width: 20px;
            height: 80px;
            margin: 5px 0;
        }

        #export-modal {
            display: none;
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: #1e1e1e;
            padding: 20px;
            border-radius: 15px;
            z-index: 100;
            width: 320px;
            border: 1px solid #444;
            pointer-events: auto;
        }

        .overlay {
            display: none;
            position: fixed;
            top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.8);
            z-index: 99;
            pointer-events: auto;
        }
        
        .label-text {
            display: block;
            font-size: 10px;
            text-transform: uppercase;
            color: #888;
            margin-bottom: 2px;
        }
    </style>
</head>
<body>

    <canvas id="canvas"></canvas>

    <div id="ui-layer">
        <div id="status-bar" class="panel">
            Zoom: <span id="zoom-val">100%</span>
        </div>

        <div id="export-panel" class="panel">
            <button onclick="showExport()" style="width: auto;">Export</button>
            <button onclick="clearCanvas()" style="color: #ff4444; width: auto;">Clear</button>
        </div>

        <div id="toolbar" class="panel">
            <span class="label-text">Color</span>
            <input type="color" id="colorPicker" value="#44ffaa">
            
            <span class="label-text">Tool</span>
            <select id="toolType">
                <option value="pen">Pen</option>
                <option value="brush">Brush</option>
                <option value="pencil">Pencil</option>
                <option value="eraser">Eraser</option>
            </select>
            
            <span class="label-text">Size</span>
            <input type="range" id="sizePicker" min="1" max="150" value="10">

            <span class="label-text">Flow</span>
            <input type="range" id="opacityPicker" min="1" max="100" value="100">
            
            <button id="btn-draw" class="tool-active" onclick="setMode('draw')" title="Draw Mode">✎</button>
            <button id="btn-pan" onclick="setMode('pan')" title="Adjust Mode">✥</button>
        </div>
    </div>

    <div id="export-modal-overlay" class="overlay" onclick="hideExport()"></div>
    <div id="export-modal">
        <h3 style="color:white; margin-top:0;">High-Res Export</h3>
        <p style="color:#888; font-size:11px; margin-bottom:15px;">This will render the <b>Entire</b> drawing area, not just what's on screen.</p>
        
        <label class="label-text">Output Width (Pixels)</label>
        <input type="number" id="expWidth" value="4096" style="width:100%; margin-bottom:10px; background:#000; color:#fff; border:1px solid #444; padding:5px;"><br>
        
        <label class="label-text">Format</label>
        <select id="expFormat" style="width: 100%; margin-bottom: 10px; height: 40px;">
            <option value="image/png">PNG (Lossless)</option>
            <option value="image/jpeg">JPEG (Compressed)</option>
        </select>

        <label class="label-text">Background</label>
        <select id="expBG" style="width: 100%; margin-bottom: 10px; height: 40px;">
            <option value="#0a0a0a">Black</option>
            <option value="#ffffff">White</option>
            <option value="transparent">Transparent (PNG)</option>
        </select>

        <label class="label-text">JPEG Quality (1-10)</label>
        <input type="number" id="expQual" value="10" style="width:100%; margin-bottom:20px; background:#000; color:#fff; border:1px solid #444; padding:5px;">
        
        <button onclick="performExport()" style="width:100%; background: var(--accent); height:auto; padding: 12px;">Process Visionary Export</button>
    </div>

<script>
    const canvas = document.getElementById('canvas');
    const ctx = canvas.getContext('2d', { alpha: false }); 
    const zoomDisplay = document.getElementById('zoom-val');
    
    let strokes = [];
    let currentStroke = null;
    let camera = { x: 0, y: 0, zoom: 1 };
    let mode = 'draw'; 
    let isDragging = false;
    let lastMousePos = { x: 0, y: 0 };
    
    let initialPinchDist = 0;
    let initialPinchZoom = 1;
    let isPinching = false;
    let lastTapTime = 0;

    let visualTouches = [];

    function resize() {
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;
    }
    window.addEventListener('resize', resize);
    resize();

    function getDist(t1, t2) {
        return Math.hypot(t1.clientX - t2.clientX, t1.clientY - t2.clientY);
    }

    // Input Logic
    canvas.addEventListener('pointerdown', e => {
        if (isPinching) return;

        if (mode === 'draw') {
            const now = Date.now();
            if (now - lastTapTime < 350) {
                undo(); 
                undo();
                lastTapTime = 0;
                isDragging = false;
                return;
            }
            lastTapTime = now;

            isDragging = true;
            lastMousePos = { x: e.clientX, y: e.clientY };

            const pos = screenToWorld(e.clientX, e.clientY);
            currentStroke = {
                color: document.getElementById('colorPicker').value,
                size: document.getElementById('sizePicker').value / camera.zoom,
                opacity: document.getElementById('opacityPicker').value / 100,
                type: document.getElementById('toolType').value,
                points: [{...pos, p: e.pressure || 0.5}]
            };
            strokes.push(currentStroke);
            if (strokes.length > 500) strokes.shift(); // Increased undo buffer for large works
            addVisualTouch(e.clientX, e.clientY);
        } else {
            isDragging = true;
            lastMousePos = { x: e.clientX, y: e.clientY };
        }
    });

    canvas.addEventListener('pointermove', e => {
        if (isPinching) return;
        if (!isDragging) return;

        if (mode === 'pan') {
            const dx = e.clientX - lastMousePos.x;
            const dy = e.clientY - lastMousePos.y;
            camera.x += dx;
            camera.y += dy;
            lastMousePos = { x: e.clientX, y: e.clientY };
        } else if (mode === 'draw' && currentStroke) {
            const pos = screenToWorld(e.clientX, e.clientY);
            currentStroke.points.push({...pos, p: e.pressure || 0.5});
            addVisualTouch(e.clientX, e.clientY);
        }
    });

    canvas.addEventListener('pointerup', () => {
        isDragging = false;
        currentStroke = null;
    });

    canvas.addEventListener('touchstart', e => {
        if (mode === 'pan' && e.touches.length === 2) {
            isPinching = true;
            isDragging = false;
            currentStroke = null;
            initialPinchDist = getDist(e.touches[0], e.touches[1]);
            initialPinchZoom = camera.zoom;
        }
    }, { passive: false });

    canvas.addEventListener('touchmove', e => {
        if (mode === 'pan' && e.touches.length === 2) {
            e.preventDefault();
            const currentDist = getDist(e.touches[0], e.touches[1]);
            const centerX = (e.touches[0].clientX + e.touches[1].clientX) / 2;
            const centerY = (e.touches[0].clientY + e.touches[1].clientY) / 2;
            const factor = currentDist / initialPinchDist;
            applyZoom(initialPinchZoom * factor / camera.zoom, centerX, centerY);
        }
    }, { passive: false });

    canvas.addEventListener('touchend', e => {
        if (e.touches.length < 2) isPinching = false;
    });

    canvas.addEventListener('wheel', e => {
        if (mode === 'pan') {
            e.preventDefault();
            const factor = Math.pow(1.1, -e.deltaY / 150);
            applyZoom(factor, e.clientX, e.clientY);
        }
    }, { passive: false });

    function applyZoom(factor, centerX, centerY) {
        const worldPos = screenToWorld(centerX, centerY);
        camera.zoom *= factor;
        if (camera.zoom < 0.00001) camera.zoom = 0.00001;
        if (camera.zoom > 10000) camera.zoom = 10000;
        camera.x = centerX - worldPos.x * camera.zoom;
        camera.y = centerY - worldPos.y * camera.zoom;
        zoomDisplay.innerText = Math.round(camera.zoom * 100) + '%';
    }

    function screenToWorld(sx, sy) {
        return { x: (sx - camera.x) / camera.zoom, y: (sy - camera.y) / camera.zoom };
    }

    function addVisualTouch(x, y) {
        visualTouches.push({
            x: x, y: y, radius: 20, alpha: 0.6,
            color: document.getElementById('colorPicker').value
        });
    }

    function undo() {
        if (strokes.length > 0) strokes.pop();
    }

    // Helper function to find the bounding box of the entire drawing
    function getDrawingBounds() {
        if (strokes.length === 0) return { minX: 0, minY: 0, maxX: 100, maxY: 100 };
        let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;
        strokes.forEach(s => {
            s.points.forEach(p => {
                if (p.x < minX) minX = p.x;
                if (p.y < minY) minY = p.y;
                if (p.x > maxX) maxX = p.x;
                if (p.y > maxY) maxY = p.y;
            });
        });
        // Add 5% padding
        const w = maxX - minX;
        const h = maxY - minY;
        return {
            minX: minX - w * 0.05,
            minY: minY - h * 0.05,
            maxX: maxX + w * 0.05,
            maxY: maxY + h * 0.05
        };
    }

    function drawPaths(targetCtx, currentCam) {
        strokes.forEach(stroke => {
            if (stroke.points.length === 0) return;
            targetCtx.save();
            targetCtx.lineCap = 'round';
            targetCtx.lineJoin = 'round';

            if (stroke.type === 'eraser') {
                targetCtx.globalCompositeOperation = 'destination-out';
                targetCtx.strokeStyle = 'white';
                targetCtx.fillStyle = 'white';
                targetCtx.globalAlpha = 1.0;
            } else {
                targetCtx.globalCompositeOperation = 'source-over';
                targetCtx.strokeStyle = stroke.color;
                targetCtx.fillStyle = stroke.color;
                targetCtx.globalAlpha = stroke.opacity;
            }

            if (stroke.type === 'brush') {
                targetCtx.shadowBlur = (stroke.size * currentCam.zoom) / 3;
                targetCtx.shadowColor = stroke.color;
            } else if (stroke.type === 'pencil') {
                targetCtx.setLineDash([1 / currentCam.zoom, 2 / currentCam.zoom]);
                targetCtx.globalAlpha *= 0.6;
            }

            if (stroke.points.length === 1) {
                const p = stroke.points[0];
                targetCtx.beginPath();
                targetCtx.arc(p.x, p.y, (stroke.size * (0.4 + p.p)) / 2, 0, Math.PI * 2);
                targetCtx.fill();
            } else {
                targetCtx.beginPath();
                targetCtx.moveTo(stroke.points[0].x, stroke.points[0].y);
                for (let i = 1; i < stroke.points.length; i++) {
                    const p = stroke.points[i];
                    targetCtx.lineWidth = stroke.size * (0.4 + p.p);
                    targetCtx.lineTo(p.x, p.y);
                }
                targetCtx.stroke();
            }
            targetCtx.restore();
        });
    }

    function renderLoop() {
        ctx.setTransform(1, 0, 0, 1, 0, 0);
        ctx.fillStyle = '#0a0a0a';
        ctx.fillRect(0, 0, canvas.width, canvas.height);
        ctx.save();
        ctx.translate(camera.x, camera.y);
        ctx.scale(camera.zoom, camera.zoom);
        drawPaths(ctx, camera);
        ctx.restore();

        visualTouches.forEach((t, i) => {
            ctx.beginPath();
            ctx.fillStyle = t.color;
            ctx.globalAlpha = t.alpha;
            ctx.arc(t.x, t.y, t.radius, 0, Math.PI * 2);
            ctx.fill();
            t.alpha -= 0.05; t.radius += 1;
            if (t.alpha <= 0) visualTouches.splice(i, 1);
        });
        requestAnimationFrame(renderLoop);
    }

    function setMode(m) {
        mode = m;
        document.getElementById('btn-draw').classList.toggle('tool-active', m === 'draw');
        document.getElementById('btn-pan').classList.toggle('tool-active', m === 'pan');
    }

    function clearCanvas() {
        if(confirm("Wipe the blackboard?")) {
            strokes = [];
            camera = { x: 0, y: 0, zoom: 1 };
            zoomDisplay.innerText = '100%';
        }
    }

    function showExport() {
        document.getElementById('export-modal').style.display = 'block';
        document.getElementById('export-modal-overlay').style.display = 'block';
    }

    function hideExport() {
        document.getElementById('export-modal').style.display = 'none';
        document.getElementById('export-modal-overlay').style.display = 'none';
    }

    function performExport() {
        if (strokes.length === 0) { alert("Nothing to export!"); return; }

        const bounds = getDrawingBounds();
        const worldW = bounds.maxX - bounds.minX;
        const worldH = bounds.maxY - bounds.minY;
        
        const exportWidth = parseInt(document.getElementById('expWidth').value);
        const format = document.getElementById('expFormat').value;
        const bgChoice = document.getElementById('expBG').value;
        
        // Calculate Height based on artwork ratio
        const exportHeight = (worldH / worldW) * exportWidth;

        const tempCanvas = document.createElement('canvas');
        tempCanvas.width = exportWidth;
        tempCanvas.height = exportHeight;
        const tCtx = tempCanvas.getContext('2d', { alpha: bgChoice === 'transparent' });

        if (bgChoice !== 'transparent') {
            tCtx.fillStyle = bgChoice;
            tCtx.fillRect(0, 0, exportWidth, exportHeight);
        }

        // Logic: Map the entire world bounding box to the 0,0 - exportWidth,exportHeight space
        const scaleFactor = exportWidth / worldW;
        
        tCtx.save();
        tCtx.scale(scaleFactor, scaleFactor);
        tCtx.translate(-bounds.minX, -bounds.minY);
        
        // Draw with a "zoom" of 1 relative to the bounds scale
        drawPaths(tCtx, { zoom: 1 });
        tCtx.restore();

        const link = document.createElement('a');
        link.download = `visionary-full-canvas-${Date.now()}.${format === 'image/jpeg' ? 'jpg' : 'png'}`;
        link.href = tempCanvas.toDataURL(format, document.getElementById('expQual').value / 10);
        link.click();
        hideExport();
    }

    if ('serviceWorker' in navigator) {
        window.addEventListener('load', () => {
            navigator.serviceWorker.register('sw.js').catch(() => {});
        });
    }

    requestAnimationFrame(renderLoop);
</script>
</body>
</html>