<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Mobile Gear Solid</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            overflow: hidden;
            background: black;
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            touch-action: none;
        }
        #gameCanvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
        }
        #controls {
            position: absolute;
            bottom: 10px;
            width: 100%;
            display: flex;
            justify-content: space-between;
            pointer-events: none;
        }
        #joystick {
            width: 150px;
            height: 150px;
            background: rgba(255,255,255,0.1);
            border-radius: 50%;
            position: relative;
            margin-left: 20px;
            pointer-events: auto;
        }
        #joystick-knob {
            width: 50px;
            height: 50px;
            background: rgba(255,255,255,0.5);
            border-radius: 50%;
            position: absolute;
            top: 50px;
            left: 50px;
        }
        #buttons {
            display: flex;
            flex-direction: column;
            margin-right: 20px;
        }
        .button {
            width: 60px;
            height: 60px;
            background: rgba(255,255,255,0.3);
            border-radius: 50%;
            margin: 10px 0;
            display: flex;
            justify-content: center;
            align-items: center;
            color: white;
            font-size: 20px;
            pointer-events: auto;
        }
        #loadingScreen, #titleScreen, #cinematicScreen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: black;
            color: white;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 10;
        }
        #loadingBar {
            width: 80%;
            height: 20px;
            background: gray;
            margin-top: 20px;
        }
        #loadingFill {
            height: 100%;
            background: green;
            width: 0%;
        }
        #cinematicText {
            width: 80%;
            height: 60%;
            background: rgba(0,0,0,0.7);
            color: green;
            font-family: monospace;
            padding: 20px;
            overflow: hidden;
            white-space: pre-wrap;
        }
        #skipButton {
            margin-top: 20px;
            padding: 10px 20px;
            background: gray;
            cursor: pointer;
        }
        #minimap {
            position: absolute;
            top: 10px;
            right: 10px;
            width: 100px;
            height: 100px;
            background: rgba(0,0,0,0.5);
        }
        #ui {
            position: absolute;
            top: 10px;
            left: 10px;
            color: white;
        }
    </style>
</head>
<body>
    <canvas id="gameCanvas"></canvas>
    <div id="controls">
        <div id="joystick">
            <div id="joystick-knob"></div>
        </div>
        <div id="buttons">
            <div class="button" id="actionA">A</div>
            <div class="button" id="actionB">B</div>
            <div class="button" id="actionY">Y</div>
        </div>
    </div>
    <div id="loadingScreen">
        <h1>Mobile Gear Solid</h1>
        <div id="loadingBar">
            <div id="loadingFill"></div>
        </div>
    </div>
    <div id="titleScreen" style="display: none;">
        <h1>Mobile Gear Solid</h1>
        <button id="startButton">Start New Game</button>
        <button id="continueButton" disabled>Continue</button>
    </div>
    <div id="cinematicScreen" style="display: none;">
        <canvas id="smokeCanvas" width="100%" height="100%" style="position: absolute; top:0; left:0;"></canvas>
        <div id="cinematicText"></div>
        <button id="skipButton">Skip</button>
    </div>
    <canvas id="minimap" width="100" height="100" style="display: none;"></canvas>
    <div id="ui" style="display: none;">
        <div>Health: <div id="healthBar" style="width:100px; height:10px; background:red; display:inline-block;"></div></div>
        <div>Weapon: <span id="weapon">None</span></div>
        <div>Item: <span id="item">None</span></div>
    </div>
    <script>
        // Game Variables
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const minimapCanvas = document.getElementById('minimap');
        const minimapCtx = minimapCanvas.getContext('2d');
        const smokeCanvas = document.getElementById('smokeCanvas');
        const smokeCtx = smokeCanvas.getContext('2d');

        let gameState = 'loading';
        let currentLevel = 0;
        let player = { x: 200, y: 500, radius: 10, speed: 2, health: 100, weapon: null, item: null };
        let enemies = [];
        let items = [];
        let walls = [];
        let alert = false;
        let cinematicText = '';
        let typingIndex = 0;
        let typingInterval;
        let smokeParticles = [];
        let afterCinematicLoad = true;

        // Levels Data (Simplified geometry based on MGS1 layouts)
        const levels = [
            // Level 0: Dock
            {
                name: 'Dock',
                background: '#333366', // Watery blue-gray
                walls: [
                    {x: 0, y: 0, w: 800, h: 20}, // Top
                    {x: 0, y: 580, w: 800, h: 20}, // Bottom
                    {x: 0, y: 0, w: 20, h: 600}, // Left
                    {x: 780, y: 0, w: 20, h: 600}, // Right
                    {x: 100, y: 400, w: 600, h: 20}, // Pipe to crawl under
                    {x: 300, y: 200, w: 200, h: 20} // Forklift
                ],
                items: [
                    {x: 50, y: 550, type: 'ration', radius: 5},
                    {x: 750, y: 550, type: 'ration', radius: 5},
                    {x: 400, y: 100, type: 'socom', radius: 5}
                ],
                enemies: [
                    {x: 400, y: 100, radius: 8, path: [{x:400,y:100},{x:600,y:100},{x:600,y:300},{x:400,y:300}], pathIndex:0, dir:1, viewAngle: Math.PI/3, viewDist: 100},
                    {x: 200, y: 200, radius: 8, path: [{x:200,y:200},{x:200,y:400}], pathIndex:0, dir:1, viewAngle: Math.PI/3, viewDist: 100},
                    {x: 500, y: 300, radius: 8, path: [{x:500,y:300},{x:700,y:300}], pathIndex:0, dir:1, viewAngle: Math.PI/3, viewDist: 100}
                ],
                exit: {x: 400, y: 50, w: 50, h: 50, nextLevel: 1, cinematic: 1, prompt: 'Tap A to call elevator'}
            },
            // Level 1: Heliport
            {
                name: 'Heliport',
                background: '#666666', // Snowy gray
                walls: [
                    {x: 0, y: 0, w: 800, h: 20},
                    {x: 0, y: 580, w: 800, h: 20},
                    {x: 0, y: 0, w: 20, h: 600},
                    {x: 780, y: 0, w: 20, h: 600},
                    {x: 200, y: 300, w: 400, h: 20}, // Helipad
                    {x: 600, y: 100, w: 100, h: 100} // Truck
                ],
                items: [
                    {x: 400, y: 320, type: 'chaff', radius: 5},
                    {x: 650, y: 120, type: 'socom', radius: 5},
                    {x: 100, y: 100, type: 'stun', radius: 5}
                ],
                enemies: [
                    {x: 300, y: 400, radius: 8, path: [{x:300,y:400},{x:500,y:400}], pathIndex:0, dir:1, viewAngle: Math.PI/3, viewDist: 150},
                    {x: 100, y: 200, radius: 8, path: [{x:100,y:200},{x:100,y:400},{x:300,y:400},{x:300,y:200}], pathIndex:0, dir:1, viewAngle: Math.PI/3, viewDist: 150}
                ],
                exit: {x: 700, y: 50, w: 50, h: 50, nextLevel: 2, cinematic: 2, prompt: 'Tap A to enter vent'} // Simplified to vent
            },
            // Level 2: Tank Hangar
            {
                name: 'Tank Hangar',
                background: '#444444', // Industrial gray
                walls: [
                    {x: 0, y: 0, w: 800, h: 20},
                    {x: 0, y: 580, w: 800, h: 20},
                    {x: 0, y: 0, w: 20, h: 600},
                    {x: 780, y: 0, w: 20, h: 600},
                    {x: 200, y: 200, w: 100, h: 100}, // Tank 1
                    {x: 500, y: 200, w: 100, h: 100}, // Tank 2
                    {x: 100, y: 400, w: 50, h: 50} // Crate
                ],
                items: [
                    {x: 50, y: 100, type: 'thermal', radius: 5},
                    {x: 750, y: 100, type: 'mine_detector', radius: 5},
                    {x: 400, y: 500, type: 'grenade', radius: 5}
                ],
                enemies: [
                    {x: 100, y: 100, radius: 8, path: [{x:100,y:100},{x:300,y:100},{x:300,y:300},{x:100,y:300}], pathIndex:0, dir:1, viewAngle: Math.PI/3, viewDist: 120},
                    {x: 600, y: 400, radius: 8, path: [{x:600,y:400},{x:700,y:400},{x:700,y:500},{x:600,y:500}], pathIndex:0, dir:1, viewAngle: Math.PI/3, viewDist: 120},
                    {x: 400, y: 150, radius: 8, path: [{x:400,y:150},{x:400,y:350}], pathIndex:0, dir:1, viewAngle: Math.PI/3, viewDist: 120}
                ],
                exit: {x: 400, y: 50, w: 50, h: 50, nextLevel: 3, cinematic: 3, prompt: 'Tap A to call elevator'} // To canyon for boss
            },
            // Level 3: Canyon (Raven Tank Boss)
            {
                name: 'Canyon',
                background: '#996633', // Desert-like for canyon
                walls: [
                    {x: 0, y: 0, w: 800, h: 20},
                    {x: 0, y: 580, w: 800, h: 20},
                    {x: 0, y: 0, w: 20, h: 600},
                    {x: 780, y: 0, w: 20, h: 600},
                    {x: 200, y: 300, w: 200, h: 50} // Rocks
                ],
                items: [
                    {x: 100, y: 500, type: 'grenade', radius: 5},
                    {x: 700, y: 500, type: 'chaff', radius: 5}
                ],
                enemies: [
                    // Boss: Tank (Simplified as large enemy)
                    {x: 400, y: 200, radius: 30, health: 100, type: 'boss', viewAngle: Math.PI/2, viewDist: 300, speed: 1}
                ],
                exit: null // End after boss
            }
        ];

        // Dialogues (Adjusted for levels)
        const dialogues = [
            // 0: Opening for Dock
            "Campbell: Snake, can you hear me?\nSnake: Loud and clear, Colonel.\nCampbell: Good. This is a solo sneaking mission. The facility is Shadow Moses Island, Alaska. Terrorists have taken over, they have Metal Gear REX. Your objective is to infiltrate, rescue the hostages: DARPA Chief Donald Anderson and ArmsTech President Kenneth Baker, and prevent a nuclear launch.\nSnake: Got it. One-man infiltration.\nCampbell: Avoid detection. Use the radar. Good luck.",
            // 1: After Dock / Heliport intro
            "Campbell: Snake, wait for the elevator. Hide behind the forklift.\nNaomi: Snake, the enemies are genome soldiers, enhanced.\nMei Ling: This is the radar. Blue is you, red dots enemies, cones their view.",
            // 2: Tank Hangar intro
            "Campbell: Find the elevator to B1. Avoid cameras.",
            // 3: Before Canyon / Raven
            "Campbell: Ahead is the canyon. Watch for the tank.\nRaven: Snake! I am Shaman! Feel the power of the tank!"
        ];

        // Resize canvas
        function resize() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
            smokeCanvas.width = window.innerWidth;
            smokeCanvas.height = window.innerHeight;
        }
        resize();
        window.addEventListener('resize', resize);

        // Joystick controls
        let joystickTouchId = null;
        let joystickCenter = {x: 75, y: 75};
        let dx = 0, dy = 0;
        const joystick = document.getElementById('joystick');
        const knob = document.getElementById('joystick-knob');

        joystick.addEventListener('touchstart', (e) => {
            const touch = e.touches[0];
            joystickTouchId = touch.identifier;
            updateJoystick(touch);
        });
        joystick.addEventListener('touchmove', (e) => {
            for (let touch of e.touches) {
                if (touch.identifier === joystickTouchId) {
                    updateJoystick(touch);
                    break;
                }
            }
        });
        joystick.addEventListener('touchend', () => {
            joystickTouchId = null;
            knob.style.left = '50px';
            knob.style.top = '50px';
            dx = 0;
            dy = 0;
        });

        function updateJoystick(touch) {
            const rect = joystick.getBoundingClientRect();
            let jx = touch.clientX - rect.left - 75;
            let jy = touch.clientY - rect.top - 75;
            const dist = Math.sqrt(jx*jx + jy*jy);
            if (dist > 50) {
                jx = (jx / dist) * 50;
                jy = (jy / dist) * 50;
            }
            knob.style.left = 50 + jx + 'px';
            knob.style.top = 50 + jy + 'px';
            dx = jx / 50;
            dy = jy / 50;
        }

        // Buttons
        let actions = {A: false, B: false, Y: false};
        ['actionA', 'actionB', 'actionY'].forEach(id => {
            const btn = document.getElementById(id);
            btn.addEventListener('touchstart', () => actions[id.slice(-1)] = true);
            btn.addEventListener('touchend', () => actions[id.slice(-1)] = false);
        });

        // Loading Screen
        function startLoading() {
            let progress = 0;
            const interval = setInterval(() => {
                progress += 20;
                document.getElementById('loadingFill').style.width = progress + '%';
                if (progress >= 100) {
                    clearInterval(interval);
                    setTimeout(() => {
                        document.getElementById('loadingScreen').style.display = 'none';
                        document.getElementById('titleScreen').style.display = 'flex';
                        gameState = 'title';
                    }, 1000);
                }
            }, 1000); // 5 seconds total
        }
        startLoading();

        // Title Screen
        document.getElementById('startButton').addEventListener('click', () => {
            document.getElementById('titleScreen').style.display = 'none';
            startCinematic(0, true);
        });

        // Cinematic
        function startCinematic(index, loadAfter = true) {
            if (index >= dialogues.length) {
                if (loadAfter) loadLevel(currentLevel);
                else gameState = 'playing';
                return;
            }
            afterCinematicLoad = loadAfter;
            gameState = 'cinematic';
            document.getElementById('cinematicScreen').style.display = 'flex';
            cinematicText = dialogues[index];
            typingIndex = 0;
            document.getElementById('cinematicText').innerHTML = '';
            typingInterval = setInterval(typeText, 50);
            initSmoke();
            animateSmoke();

            document.getElementById('skipButton').onclick = () => {
                clearInterval(typingInterval);
                document.getElementById('cinematicText').innerHTML = cinematicText;
                setTimeout(endCinematic, 2000);
            };
        }

        function typeText() {
            if (typingIndex < cinematicText.length) {
                document.getElementById('cinematicText').innerHTML += cinematicText[typingIndex];
                typingIndex++;
            } else {
                clearInterval(typingInterval);
                setTimeout(endCinematic, 3000);
            }
        }

        function endCinematic() {
            document.getElementById('cinematicScreen').style.display = 'none';
            if (afterCinematicLoad) {
                loadLevel(currentLevel);
            } else {
                gameState = 'playing';
            }
        }

        // Smoke Background
        function initSmoke() {
            smokeParticles = [];
            for (let i = 0; i < 100; i++) {
                smokeParticles.push({
                    x: Math.random() * smokeCanvas.width,
                    y: Math.random() * smokeCanvas.height,
                    radius: Math.random() * 20 + 10,
                    speed: Math.random() * 0.5 + 0.1,
                    opacity: Math.random() * 0.5 + 0.1
                });
            }
        }

        function animateSmoke() {
            if (gameState !== 'cinematic') return;
            smokeCtx.clearRect(0, 0, smokeCanvas.width, smokeCanvas.height);
            smokeParticles.forEach(p => {
                smokeCtx.beginPath();
                smokeCtx.arc(p.x, p.y, p.radius, 0, Math.PI*2);
                smokeCtx.fillStyle = `rgba(200,200,200,${p.opacity})`;
                smokeCtx.fill();
                p.y -= p.speed;
                p.x += Math.sin(p.y / 50) * 0.5; // Wavy motion
                if (p.y < -p.radius) p.y = smokeCanvas.height + p.radius;
            });
            requestAnimationFrame(animateSmoke);
        }

        // Load Level
        function loadLevel(level) {
            currentLevel = level;
            const lev = levels[level];
            walls = lev.walls;
            items = lev.items;
            enemies = lev.enemies;
            player.x = 200;
            player.y = 500;
            alert = false;
            gameState = 'playing';
            document.getElementById('minimap').style.display = 'block';
            document.getElementById('ui').style.display = 'block';
            document.getElementById('healthBar').style.width = player.health + 'px';
            gameLoop();
        }

        // Collision Detection
        function collides(a, b) {
            if ('radius' in a && 'radius' in b) {
                const dist = Math.sqrt((a.x - b.x)**2 + (a.y - b.y)**2);
                return dist < a.radius + b.radius;
            } else {
                return a.x + a.radius > b.x && a.x - a.radius < b.x + b.w &&
                       a.y + a.radius > b.y && a.y - a.radius < b.y + b.h;
            }
        }

        // Vision Check
        function inVision(player, enemy) {
            const dx = player.x - enemy.x;
            const dy = player.y - enemy.y;
            const dist = Math.sqrt(dx*dx + dy*dy);
            if (dist > enemy.viewDist) return false;
            const angle = Math.atan2(dy, dx);
            const enemyDir = getEnemyDirection(enemy); // Improved
            const angleDiff = Math.min(Math.abs(angle - enemyDir), 2*Math.PI - Math.abs(angle - enemyDir));
            return angleDiff < enemy.viewAngle / 2;
        }

        function getEnemyDirection(enemy) {
            // Assume direction based on movement
            if (enemy.path) {
                const next = enemy.path[enemy.pathIndex + enemy.dir] || enemy.path[enemy.pathIndex];
                const dx = next.x - enemy.x;
                const dy = next.y - enemy.y;
                return Math.atan2(dy, dx);
            }
            return 0;
        }

        // Game Loop
        function gameLoop() {
            if (gameState !== 'playing') return;

            // Clear
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            ctx.fillStyle = levels[currentLevel].background;
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // Player Movement
            let newX = player.x + dx * player.speed;
            let newY = player.y + dy * player.speed;
            let canMove = true;
            walls.forEach(w => {
                if (collides({x: newX, y: newY, radius: player.radius}, w)) canMove = false;
            });
            if (canMove) {
                player.x = newX;
                player.y = newY;
            }

            // Draw Walls
            ctx.fillStyle = '#222';
            walls.forEach(w => ctx.fillRect(w.x, w.y, w.w, w.h));

            // Items
            items.forEach((it, i) => {
                ctx.fillStyle = 'yellow';
                ctx.beginPath();
                ctx.arc(it.x, it.y, it.radius, 0, Math.PI*2);
                ctx.fill();
                // Spin effect
                it.angle = (it.angle || 0) + 0.1;
                if (collides(player, it)) {
                    if (it.type === 'ration') player.health = Math.min(100, player.health + 20);
                    else if (it.type === 'socom') player.weapon = 'SOCOM';
                    else if (it.type === 'grenade') player.item = 'Grenade';
                    else if (it.type === 'chaff') player.item = 'Chaff';
                    else if (it.type === 'stun') player.item = 'Stun';
                    else if (it.type === 'thermal') player.item = 'Thermal';
                    else if (it.type === 'mine_detector') player.item = 'Mine Detector';
                    items.splice(i, 1);
                    document.getElementById('healthBar').style.width = player.health + 'px';
                    document.getElementById('weapon').innerText = player.weapon || 'None';
                    document.getElementById('item').innerText = player.item || 'None';
                }
            });

            // Enemies
            enemies.forEach(e => {
                // Patrol
                if (!alert && !e.type) {
                    if (e.path) {
                        const target = e.path[e.pathIndex];
                        const dx = target.x - e.x;
                        const dy = target.y - e.y;
                        const dist = Math.sqrt(dx*dx + dy*dy);
                        if (dist < 1) {
                            e.pathIndex += e.dir;
                            if (e.pathIndex >= e.path.length || e.pathIndex < 0) e.dir = -e.dir;
                            e.pathIndex = Math.max(0, Math.min(e.path.length - 1, e.pathIndex));
                        } else {
                            e.x += (dx / dist) * 1;
                            e.y += (dy / dist) * 1;
                        }
                    }
                }

                // Vision Cone
                ctx.fillStyle = 'rgba(255,0,0,0.2)';
                ctx.beginPath();
                ctx.moveTo(e.x, e.y);
                const dir = getEnemyDirection(e);
                ctx.arc(e.x, e.y, e.viewDist, dir - e.viewAngle/2, dir + e.viewAngle/2);
                ctx.fill();

                // Draw Enemy
                ctx.fillStyle = 'red';
                ctx.beginPath();
                ctx.arc(e.x, e.y, e.radius, 0, Math.PI*2);
                ctx.fill();

                // Detection
                if (inVision(player, e) && !alert) {
                    alert = true;
                    ctx.fillStyle = 'red';
                    ctx.font = '40px Arial';
                    ctx.fillText('ALERT!', canvas.width/2 - 100, canvas.height/2);
                }

                if (alert && !e.type) {
                    // Chase
                    const dx = player.x - e.x;
                    const dy = player.y - e.y;
                    const dist = Math.sqrt(dx*dx + dy*dy);
                    if (dist > 1) {
                        e.x += (dx / dist) * 1.5;
                        e.y += (dy / dist) * 1.5;
                    }
                    if (collides(player, e)) player.health -= 0.5;
                }

                // Boss
                if (e.type === 'boss') {
                    const dx = player.x - e.x;
                    const dy = player.y - e.y;
                    const dist = Math.sqrt(dx*dx + dy*dy);
                    if (dist > 50) {
                        e.x += (dx / dist) * e.speed;
                        e.y += (dy / dist) * e.speed;
                    }
                    if (dist < 200) player.health -= 0.1;
                    if (collides(player, e)) player.health -= 1;

                    // Damage with grenade or chaff
                    if (actions.B && (player.item === 'Grenade' || player.item === 'Chaff') && dist < 50) {
                        e.health -= 10;
                        actions.B = false;
                    }
                    if (e.health <= 0) {
                        endGame();
                    }
                }
            });

            // Player
            ctx.fillStyle = 'blue';
            ctx.beginPath();
            ctx.arc(player.x, player.y, player.radius, 0, Math.PI*2);
            ctx.fill();

            // Exit
            const lev = levels[currentLevel];
            if (lev.exit && collides(player, lev.exit)) {
                ctx.fillStyle = 'white';
                ctx.font = '20px Arial';
                ctx.fillText(lev.exit.prompt, player.x, player.y - 20);
                if (actions.A) {
                    actions.A = false;
                    currentLevel = lev.exit.nextLevel;
                    startCinematic(lev.exit.cinematic, true);
                }
            }

            // Random Codec
            if (Math.random() < 0.0005) { // Rare
                ctx.fillText('Tap Y to answer', player.x, player.y - 40);
                if (actions.Y) {
                    actions.Y = false;
                    const randIndex = Math.floor(Math.random() * dialogues.length);
                    startCinematic(randIndex, false);
                }
            }

            // Attack / Action B
            if (actions.B) {
                if (player.weapon === 'SOCOM') {
                    // Shoot
                    enemies.forEach((e, i) => {
                        const dx = e.x - player.x;
                        const dy = e.y - player.y;
                        const dist = Math.sqrt(dx*dx + dy*dy);
                        if (dist < 50) { // Close range for simplicity
                            if (e.type === 'boss') e.health -= 5;
                            else enemies.splice(i, 1);
                        }
                    });
                } else {
                    // Punch
                    enemies.forEach((e, i) => {
                        if (collides({x: player.x + 20 * dx, y: player.y + 20 * dy, radius: 5}, e)) {
                            if (e.type === 'boss') e.health -= 2;
                            else enemies.splice(i, 1);
                        }
                    });
                }
                actions.B = false;
            }

            // Health check
            document.getElementById('healthBar').style.width = player.health + 'px';
            if (player.health <= 0) endGame(false);

            // Minimap
            minimapCtx.clearRect(0, 0, 100, 100);
            const scaleX = 100 / 800;
            const scaleY = 100 / 600;
            minimapCtx.fillStyle = 'blue';
            minimapCtx.beginPath();
            minimapCtx.arc(player.x * scaleX, player.y * scaleY, 2, 0, Math.PI*2);
            minimapCtx.fill();
            enemies.forEach(e => {
                minimapCtx.fillStyle = 'red';
                minimapCtx.beginPath();
                minimapCtx.arc(e.x * scaleX, e.y * scaleY, 2, 0, Math.PI*2);
                minimapCtx.fill();
                minimapCtx.fillStyle = 'rgba(255,0,0,0.2)';
                minimapCtx.beginPath();
                minimapCtx.moveTo(e.x * scaleX, e.y * scaleY);
                const dir = getEnemyDirection(e);
                minimapCtx.arc(e.x * scaleX, e.y * scaleY, e.viewDist * scaleX, dir - e.viewAngle/2, dir + e.viewAngle/2);
                minimapCtx.fill();
            });

            requestAnimationFrame(gameLoop);
        }

        // End Game
        function endGame(win = true) {
            gameState = 'end';
            ctx.fillStyle = 'black';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            ctx.fillStyle = 'white';
            ctx.font = '40px Arial';
            ctx.fillText(win ? 'Thanks for playing!' : 'Game Over', canvas.width/2 - 200, canvas.height/2);
        }
    </script>
</body>
</html>